const baseURL = 'https://www2.gogoanime.cm';

const defaultHeaders: Map<str> = {
    'User-Agent': httpUserAgent(),
    'Referer': baseURL,
}

var dom = null;

fun getDOM(trace: TaskTrace) {
    if (dom != null && !dom.disposed) {
        trace.add('Returning previous DOM');
        return dom;
    }

    trace.add('Creating new DOM');
    return resolveFuture(createDOM(), fun (err, res) {
        if (err != null) return throwError(err);
        dom = res;
        return dom;
    });
}

fun getSite(url: str, trace: TaskTrace) {
    trace.add('Preparing DOM');
    return resolveFuture(getDOM(trace), fun (err, tab) {
        if (err != null) return throwError(err, trace);

        trace.add('Opening URL: "${url}"');
        return resolveFuture(tab.open(url, 'domContentLoaded'), fun (err, mt) {
            if (err != null) return throwError(err, trace);

            trace.add('Trying to bypass cloudflare');
            return resolveFuture(tryBypassCloudflareCheck(tab), fun (err, bypassed) {
                if (err != null) return throwError(err, trace);
                if (!bypassed) return throwError('Failed to bypass cloudflare', trace);

                return tab;
            });
        });
    });
}

fun searchURL(terms: str) -> str {
    return ensureURL('${baseURL}/search.html?keyword=${terms}');
}

fun episodesApiURL(id: num, start: num, end: num) -> str {
    return ensureURL('https://ajax.gogo-load.com/ajax/load-list-episode?ep_start=${start}&ep_end=${end}&id=${id}');
}

fun defaultLocale() -> str {
    return "en";
}

fun search(terms: str, locale: str) {
    const trace = TaskTrace();
    const url: str = searchURL(terms);
    
    trace.add('Getting URL: "${url}"');
    return resolveFuture(getSite(url, trace), fun (err, tab) {
        if (err != null) return throwError(err, trace);

        trace.add('Getting HTML of "${url}"');
        return resolveFuture(tab.getHtml(), fun (err, html) {
            if (err != null) return throwError(err, trace);
            if (html == null) return throwError('No html was received', trace);

            const document: HtmlElement = parseHtml(html);

            return mapList(document.querySelectorAll('.items li'), fun (i: num, x: HtmlElement) {
                const title: HtmlElement = x.querySelector('.name a');
                const url: str = title.attributes['href'].trim();
                const thumbnail: str = x.querySelector('.img img').attributes['src'].trim();

                return {
                    'title': title.text.trim(),
                    'url': ensureURL('${baseURL}${url}'),
                    'thumbnail': {
                        'url': ensureURL(thumbnail),
                        'headers': defaultHeaders,
                    },
                    'locale': locale,
                };
            });
        });
    });
}

fun getInfo(url: str, locale: str) {
    const trace = TaskTrace();
    const url: str = ensureURL(url);
    
    trace.add('Getting URL: "${url}"');
    return resolveFuture(getSite(url, trace), fun (err, tab) {
        if (err != null) return throwError(err, trace);

        trace.add('Getting HTML of "${url}"');
        return resolveFuture(tab.getHtml(), fun (err, html) {
            if (err != null) return throwError(err, trace);
            if (html == null) return throwError('No html was received', trace);

            const document: HtmlElement = parseHtml(html);

            const epPages: List<HtmlElement> = document.querySelectorAll('#episode_page a');
            const epStart: str = epPages.first.attributes['ep_start'].trim();
            const epEnd: str = epPages.last.attributes['ep_end'].trim();
            const epId: str = document.querySelector('input#movie_id').attributes['value'].trim();
            const epURL: str = episodesApiURL(epId, epStart, epEnd);

            trace.add('Getting URL: "${epURL}"');
            return resolveFuture(getSite(epURL, trace), fun (err, tab) {
                if (err != null) return throwError(err, trace);
                
                trace.add('Getting HTML of "${epURL}"');
                return resolveFuture(tab.getHtml(), fun (err, epHtml) {
                    if (err != null) return throwError(err, trace);

                    const episodes: Map = mapList(parseHtml(epHtml).querySelectorAll('#episode_related a'), fun (i: num, x: HtmlElement) {
                        const episode: str = x.querySelector('.name').text.replaceFirst('EP', '').trim();
                        const url: str = x.attributes['href'].trim();
                        return {
                            'episode': episode,
                            'url': ensureURL('${baseURL}/${url}'),
                            'locale': locale
                        }
                    });

                    return {
                        'title': document.querySelector('.anime_info_body_bg h1').text.trim(),
                        'url': ensureURL(url),
                        'thumbnail': {
                            'url': ensureURL(document.querySelector('.anime_info_body_bg img').attributes['src'].trim()),
                            'headers': defaultHeaders,
                        },
                        'episodes': episodes,
                        'locale': locale,
                        'availableLocales': [
                            locale
                        ]
                    };
                });
            });
        });
    });
}

fun getSources(episode: Map) {
    const trace = TaskTrace();
    const url: str = episode['url'];

    trace.add('Getting URL: "${url}"');
    return resolveFuture(getSite(url, trace), fun (err, tab) {
        if (err != null) return throwError(err, trace);

        trace.add('Getting HTML of "${url}"');
        return resolveFuture(tab.getHtml(), fun (err, html) {
            if (err != null) return throwError(err, trace);
            if (html == null) return throwError('No html was received', trace);

            const defaultSourceProps: Map = {
                'quality': 'unknown',
                'locale': episode['locale']
            };

            return resolveFutureAll(
                filterList(
                    mapList(parseHtml(html).querySelectorAll('.anime_muti_link ul > li'), fun (i: num, x: HtmlElement) {
                        const link: str = x.querySelector('a').attributes['data-video'];

                        if (link != null) {
                            if (x.classes.contains('streamsb')) {
                                return parseSbPlay(link, defaultSourceProps);
                            } else if (x.classes.contains('xstreamcdn')) {
                                return parseXstreamCdn(link, defaultSourceProps);
                            }
                            // TODO: Test streamtape links
                            // else if (testStreamTape(xlink)) {
                            //    return parseStreamTape(link, defaultSourceProps);
                            // }
                        }

                        return null;
                    }),
                    fun (i: num, x) {
                        return x != null;
                    }
                ),
                fun (err, res) {
                    if (err != null) return throwError(err);
                    return flattenList(res, 1);
                }
            );
        });
    });
}

// SbPlay Scraper
const sbPlayURL = 'https://sbplay.org';
const sbPlayHeaders = {
    'User-Agent': httpUserAgent(),
};

fun parseSbPlay(url: str, defaultResult: Map) {
    return resolveFuture(fetch({
        'method': 'get',
        'url': ensureURL(regexReplaceFirst(url, '(\\/embed-|\\/e\\/)', '/d/')),
        'headers': sbPlayHeaders
    }), fun (err, resp) {
        return resolveFutureAll(
            mapList(
                regexMatchAll('onclick="download_video\\(\'([^\']+)\',\'([^\']+)\',\'([^\']+)\'\\)"', resp['body']),
                fun (i: num, x: RegExpMatchResult) {
                    const code: str = x.group(1);
                    const mode: str = x.group(2);
                    const hash: str = x.group(3);

                    return wait(3000, fun () {
                        return resolveFuture(fetch({
                            'method': 'get',
                            'url': '${sbPlayURL}/dl?op=download_orig&id=${code}&mode=${mode}&hash=${hash}',
                            'headers': sbPlayHeaders
                        }), fun (err, resp) {
                            if (err != null) return throwError(err);

                            const match = regexMatch('<a href="([^"]+)">Direct Download Link<\\/a>', resp['body']);
                            return match != null ? mergeMap(defaultResult, {
                                'url': ensureURL(match.group(1)),
                                'headers': sbPlayHeaders
                            }) : null;
                        });
                    });
                }
            ),
            fun (err, res) {
                if (err != null) return throwError(err);
                return filterList(res, fun (i: num, x) {
                    return x != null;
                });
            }
        );
    });
}

// StreamTape Scraper
const streamTapeURL = 'https://streamtape.com';
const streamTapeHeaders = {
    'User-Agent': httpUserAgent(),
};

fun parseStreamTape(url: str, defaultResult: Map) {
    return resolveFuture(fetch({
        'method': 'get',
        'url': ensureURL(url),
        'headers': streamTapeHeaders
    }), fun (err, resp) {
        const match = regexMatch('id="videolink"[\\s\\S]+\\.innerHTML[\\s]+=[\\s\\S]+(id=[^\'"]+)', resp['body']);
        const params: str = match != null ? match.group(1) : null;

        return params != null ? [
            mergeMap(defaultResult, {
                'url': ensureURL('${streamTapeURL}/get_video?${params}'),
                'headers': streamTapeHeaders
            })
        ] : [];
    });
}

// XStreamCDN Scraper
const xstreamCdnURL = 'https://embedsito.com';
const xstreamCdnHeaders = {
    'User-Agent': httpUserAgent(),
    'Referer': xstreamCdnURL
};

fun parseXstreamCdn(url: str, defaultResult: Map) {
    return resolveFuture(fetch({
        'method': 'post',
        'url': ensureURL(url.replaceFirst('/v', '/api/source')),
        'headers': xstreamCdnHeaders
    }), fun (err, resp) {
        const parsed: Map = jsonDecode(resp['body']);

        return filterList(
            mapList(parsed['data'], fun (i: num, x: Map) {
                if (x['type'] != 'mp4') return null;

                return mergeMap(defaultResult, {
                    'url': ensureURL(x['file']),
                    'quality': x['label'],
                    'headers': xstreamCdnHeaders
                });
            }),
            fun (i: num, x) {
                return x != null;
            }
        );
    });
}