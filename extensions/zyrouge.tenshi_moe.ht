const baseURL = 'https://tenshi.moe';

const defaultHeaders: Map<str> = {
    'User-Agent': httpUserAgent(),
    'Referer': baseURL,
}

var dom = null;

fun getDOM(trace: TaskTrace) {
    if (dom != null && !dom.disposed) {
        trace.add('Returning previous DOM');
        return dom;
    }

    trace.add('Creating new DOM');
    return resolveFuture(createDOM(), fun (err, res) {
        if (err != null) return throwError(err);
        dom = res;
        return dom;
    });
}

fun getSite(url: str, trace: TaskTrace) {
    trace.add('Preparing DOM');
    return resolveFuture(getDOM(trace), fun (err, tab) {
        if (err != null) return throwError(err, trace);

        trace.add('Opening URL: "${url}"');
        return resolveFuture(tab.open(url, 'domContentLoaded'), fun (err, mt) {
            if (err != null) return throwError(err, trace);

            trace.add('Trying to bypass browser check');
            return resolveFuture(tryBypassBrowserChecks(tab, fun (html) {
                return html.contains('href="https://ddos-guard.net"');
            }), fun (err, bypassed) {
                if (err != null) return throwError(err, trace);
                if (!bypassed) return throwError('Failed to bypass browser check', trace);

                return tab;
            });
        });
    });
}

fun searchURL(terms: str) -> str {
    return ensureURL('${baseURL}/anime?q=${terms}');
}

fun defaultLocale() -> str {
    return "en";
}

fun search(terms: str, locale: str) {
    const trace = TaskTrace();
    const url: str = searchURL(terms);

    return resolveFuture(getSite(url, trace), fun (err, tab) {
        if (err != null) return throwError(err, trace);

        return resolveFuture(tab.getHtml(), fun (err, html) {
            if (err != null) return throwError(err, trace);

            const document: HtmlElement = parseHtml(html);

            return mapList(document.querySelectorAll('.anime-loop li'), fun (i: num, x: HtmlElement) {
                const link: HtmlElement = x.querySelector('a');
                const title: str = link.querySelector('.label .text-primary').text.trim();
                const url: str = link.attributes['href'].trim();

                return {
                    'title': title,
                    'url': ensureURL(url),
                    'locale': locale,
                };
            });
        });
    });
}

fun getInfo(url: str, locale: str) {
    const trace = TaskTrace();
    const url: str = ensureURL(url);

    return resolveFuture(getSite(url, trace), fun (err, tab) {
        if (err != null) return throwError(err, trace);

        return resolveFuture(tab.getHtml(), fun (err, html) {
            if (err != null) return throwError(err, trace);

            const document: HtmlElement = parseHtml(html);

            const estimated: str = document.querySelector('.entry-episodes .badge.badge-secondary.align-top').text.trim();
            const trimmedURL: str = url.endsWith('/') ? url.substring(0, url.length - 1) : url;
            const episodes: Map = mapList(rangeList(0, int.parse(estimated)), fun (i: num, x: num) {
                const epNum: num = '${x + 1}';
                return {
                    'episode': epNum,
                    'url': ensureURL('${trimmedURL}/${epNum}'),
                    'locale': locale
                }
            });

            return {
                'title': document.querySelector('.entry-header').text.trim(),
                'url': ensureURL(url),
                'thumbnail': {
                    'url': ensureURL(document.querySelector('img.cover-image').attributes['src'].trim()),
                    'headers': defaultHeaders,
                },
                'episodes': episodes,
                'locale': locale,
                'availableLocales': [
                    locale
                ]
            };
        });
    });
}

fun getSources(episode: Map) {
    const trace = TaskTrace();
    const url: str = episode['url'];

    return resolveFuture(getSite(url, trace), fun (err, tab) {
        if (err != null) return throwError(err, trace);

        return resolveFuture(tab.getHtml(), fun (err, html) {
            if (err != null) return throwError(err, trace);

            const iframeURL: str = regexMatch('<iframe src="([^"]+)"', html).group(1);
            const epHeaders: Map = mergeMap(defaultHeaders, {
                'Referer': episode['url'],
            });

            return resolveFuture(getSite(iframeURL, trace), fun (err, tab2) {
                if (err != null) return throwError(err, trace);

                return resolveFuture(tab2.getHtml(), fun (err, html2) {
                    const sources: str = regexMatch('sources:[\\s]+\\[([^\\]]+)', html2).group(1);
                    return mapList(regexMatchAll('src:[\\s]+["\']([^\'"]+)[\\S\\s]+size:[\\s]+(\\d+)', sources), fun (i: num, x: RegExpMatchResult) {
                        return {
                            'url': ensureURL(x.group(1)),
                            'quality': x.group(2),
                            'headers': epHeaders,
                            'locale': episode['locale']
                        };
                    });  
                });
            });
        });
    });
}
