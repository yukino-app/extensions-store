const baseURL = 'https://twist.moe';
const apiURL = 'https://api.twist.moe/api';

const _twistDecryptKey = '267041df55ca2b36f2e322d05ee2c9cf';
const _twistAccessToken = '0df14814b9e590a1f26d3071a4ed7974';

const defaultHeaders: Map<str> = {
    'User-Agent': httpUserAgent(),
    'Referer': baseURL,
    'x-access-token': _twistAccessToken,
}

fun searchApiURL() -> str {
    return '${apiURL}/anime';
}

fun animeURL(slug: str) -> str {
    return ensureURL('${baseURL}/a/${slug}');
}

fun animeApiURL(slug: str) -> str {
    return ensureURL('${apiURL}/anime/${slug}');
}

fun animeSourcesURL(slug: str) -> str {
    return'${animeApiURL(slug)}/sources';
}

fun extractSlugFromURL(url: str) {
    const match = regexMatch('https?:\\/\\/twist\\.moe\\/a\\/([^\\/]+)', url);
    return match != null ? match.group(1) : null;
}

fun defaultLocale() -> str {
    return "en";
}

let searcher = null;
fun search(terms: str, locale: str) {
    if (searcher != null) {
        return searcher(terms, 10);
    }

    return resolveFuture(fetch({
        'method': 'get',
        'url': searchApiURL(),
        'headers': defaultHeaders
    }), fun (err, resp) {
        if (err != null) return throwError(err);

        const data: List<Map> = mapList(jsonDecode(resp['body']), fun (i: num, x: Map) {
            return {
                'title': x['title'],
                'altTitle': x['altTitle'] != null ? x['altTitle'] : '',
                'url': ensureURL(animeURL(x['slug']['slug'])),
                'locale': locale,
            };
        });

        searcher = createFuzzy(data, [{
            'key': 'title',
            'weight': 2
        }, {
            'key': 'altTitle',
            'weight': 1
        }]);

        return searcher(terms, 10);
    });
}

fun getInfo(url: str, locale: str) {
    const slug = extractSlugFromURL(url);
    if (slug == null) {
        return throwError('Failed to parse "slug"');
    }

    return resolveFuture(fetch({
        'method': 'get',
        'url': animeApiURL(slug),
        'headers': defaultHeaders
    }), fun (err, resp) {
        if (err != null) return throwError(err);

        const parsed: Map = jsonDecode(resp['body']);
        const animeURLP = animeURL(slug);

        return {
            'title': parsed['title'],
            'url': animeURLP,
            'episodes': mapList(parsed['episodes'], fun (i: num, x: Map) {
                const epNum = x['number'].toString();
                return {
                    'episode': epNum,
                    'url': ensureURL('${animeURLP}/${epNum}'),
                    'locale': locale,
                };
            }),
            'locale': locale,
            'availableLocales': [
                locale
            ]
        };
    });
}

const sourceCache: Map<List<Map>> = {};
fun getSources(episode: Map) {
    const slug = extractSlugFromURL(episode['url']);
    if (slug == null) {
        return throwError('Failed to parse "slug"');
    }

    const ep: num = int.parse(episode['episode']);

    fun returnFromCache() {
        const src = findList(sourceCache[slug], fun (i: num, x: Map) {
            return x['episode'] == ep;
        });
        if (src == null) {
            return throwError('Unknown episode: ${ep}');
        }

        if (src['url'] == null) {
            const decrypted = decryptCryptoJsAES(src['source'], _twistDecryptKey, 48);
            src['url'] = ensureURL('https://cdn.twist.moe${decrypted}');
        }

        return [src];
    }

    if (sourceCache[slug] != null) {
        return returnFromCache();
    }

    return resolveFuture(fetch({
        'method': 'get',
        'url': animeSourcesURL(slug),
        'headers': defaultHeaders
    }), fun (err, resp) {
        if (err != null) return throwError(err);

        const parsed: List<Map> = jsonDecode(resp['body']);

        sourceCache[slug] = mapList(parsed, fun (i: num, x: Map) {
            const ep: num = x['number'];
            return {
                'episode': ep,
                'quality': 'unknown',
                'source': x['source'],
                'headers': {
                  'Referer': ensureURL('${baseURL}/a/${slug}/${ep}'),
                  'User-Agent': httpUserAgent()
                },
                'locale': episode['locale']
            };
        });

        return returnFromCache();
    });
}
