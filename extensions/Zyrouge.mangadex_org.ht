const baseURL = 'https://mangadex.org';
const apiURL = 'https://api.mangadex.org';
const uploadsURL = 'https://uploads.mangadex.org';

const defaultHeaders: Map<str> = {
    'Origin': baseURL,
    'Referer': baseURL,
};

fun searchApiURL(terms: str) -> str {
    return '${apiURL}/manga?title=${terms}';
}

fun mangaApiURL(id: str) -> str {
    return '${apiURL}/manga/${id}';
}

fun mangaFeedApiURL(id: str, locale: str, limit: num, offset: num) -> str {
    return '${apiURL}/manga/${id}/feed?limit=${limit}&offset=${offset}&order[chapter]=asc&translatedLanguage[]=${locale}';
}

fun mangaChapterOverviewURL(id: str, chapter: int, volume: int, limit: int) -> str {
    return '${apiURL}/chapter?manga=${id}&chapter=${chapter}&volume=${volume}&limit=${limit}&order[chapter]=asc';
}

fun mangaServerApiURL(id: str) -> str {
    return '${apiURL}/at-home/server/${id}';
}

fun chapterApiURL(serverURL: str, quality: str, hash: str) -> str {
    return '${serverURL}/${quality}/${hash}';
}

fun pageSourceURL(chapterApiURL: str, filename: str) -> str {
    return '${chapterApiURL}/${filename}';
}

fun coverAPIURL(coverID: str) -> str {
    return '${apiURL}/cover/${coverID}';
}

fun coverURL(mangaID: str, coverFile: str) -> str {
    return '${uploadsURL}/covers/${mangaID}/${coverFile}';
}

fun extractIdFromURL(url: str) -> str {
    return regexMatch('https?:\\/\\/api\\.mangadex\\.org\\/manga\\/([^\\/]+)', url).group(1);
}

const GetCoverImageCallback: type = fun(cover: str);
fun getCoverImageURL(manga: str, cover: str, cb: GetCoverImageCallback) {
    return resolveFuture(fetch({
        'method': 'get',
        'url': coverAPIURL(cover),
        'headers': defaultHeaders,
    }), fun (err, resp) {
        if (err != null) return throwError(err);

        const parsed: Map = jsonDecode(resp['body']);

        return cb({
            'url': ensureURL(coverURL(manga, parsed['data']['attributes']['fileName'])),
            'headers': defaultHeaders
        });
    });
}

const _allLanguagesCache: List<str> = allLanguages();
const GetAvailableLanguagesCallback: type = fun(langs: List<str>);
fun getAvailableLanguages(manga: str, cb: GetAvailableLanguagesCallback) {
    return resolveFuture(fetch({
        'method': 'get',
        'url': ensureURL(mangaChapterOverviewURL(manga, 1, 1, 100)),
        'headers': defaultHeaders,
    }), fun (err, resp) {
        if (err != null) return throwError(err);
        
        const parsed: Map = jsonDecode(resp['body']);
        const langs: List<str> = filterList(mapList(parsed['data'], fun (i: num, x: Map) {
            const code = regexMatch('\\w+', x['attributes']['translatedLanguage']);
            return code != null ? code.group(0) : null;
        }), fun (i: num, x) {
            return x != null && _allLanguagesCache.contains(x);
        });

        return cb(langs);
    });
}

fun defaultLocale() -> str {
    return "en";
}

fun search(terms: str, locale: str) {
    return resolveFuture(fetch({
        'method': 'get',
        'url': searchApiURL(terms),
        'headers': defaultHeaders,
    }), fun (err, resp) {
        if (err != null) return throwError(err);

        const data = jsonDecode(resp['body'])['data'];

        return resolveFutureAll(
            mapList(data.sublist(0, data.length > 10 ? 10 : data.length), fun (i: num, x: Map) {
                const coverArt = findList(x['relationships'], fun (i: num, x: Map) {
                    return x['type'] == 'cover_art';
                });

                fun finish(cover) -> Map {
                    return {
                        'title': x['attributes']['title'][defaultLocale()],
                        'url': mangaApiURL(x['id']),
                        'thumbnail': cover,
                        'locale': locale,
                    };
                }

                return coverArt != null
                    ? getCoverImageURL(x['id'], coverArt['id'], finish)
                    : finish(null);
            }),
            fun (err, res) {
                if (err != null) return throwError(err);
                return res;
            }
        );
    });
}

const _chapterLimit = 500;
const _chapterInfoCache: Map = {};
const _serverURLPlaceholder: str = '{&server_url&}';
fun getInfo(url: str, locale: str) {
    const id: str = extractIdFromURL(url);
    const mangaURL: str = ensureURL(mangaApiURL(id));

    return resolveFuture(fetch({
        'method': 'get',
        'url': mangaURL,
        'headers': defaultHeaders
    }), fun (err, resp) {
        if (err != null) return throwError(err);

        const parsed = jsonDecode(resp['body']);
        const coverArt = findList(parsed['data']['relationships'], fun (i: num, x: Map) {
            return x['type'] == 'cover_art';
        });

        return getAvailableLanguages(id, fun (langs: List<str>) {
            fun finish(cover) {
                fun resolveChapters(info: Map, offset: num) {
                    return resolveFuture(fetch({
                        'method': 'get',
                        'url': ensureURL(mangaFeedApiURL(id, locale, _chapterLimit, offset)),
                        'headers': defaultHeaders
                    }), fun (err, resp) {
                        if (err != null) return throwError(err);


                        const chapters: List<Map> = mapList(jsonDecode(resp['body'])['data'], fun (i: num, x: Map) {
                            const title = x['attributes']['title'];
                            const url = chapterApiURL(_serverURLPlaceholder, 'data', x['attributes']['hash']);

                            _chapterInfoCache[url] = {
                                'id': x['id'],
                                'files': x['attributes']['data'],
                            };

                            return {
                                'title': title != null && title.isNotEmpty ? title : null,
                                'url': url,
                                'chapter': x['attributes']['chapter'],
                                'volume': x['attributes']['volume'],
                                'locale': locale,
                            };
                        });

                        const nInfo = mergeMap(info, {
                            'chapters': mergeList(info['chapters'], chapters)
                        });

                        return chapters.isNotEmpty
                            ? resolveChapters(nInfo, offset + _chapterLimit)
                            : nInfo;
                    });
                }

                const localeTitle = parsed['data']['attributes']['title'][locale];
                const defaultLocaleTitle = parsed['data']['attributes']['title'][defaultLocale()];

                return resolveChapters({
                    'title': localeTitle != null ? localeTitle : defaultLocaleTitle,
                    'url': mangaURL,
                    'thumbnail': cover,
                    'chapters': [],
                    'locale': locale,
                    'availableLocales': langs
                }, 0);
            }

            return coverArt != null
                ? getCoverImageURL(parsed['data']['id'], coverArt['id'], finish)
                : finish(null);
        });
    });
}

fun getChapter(chapter: Map) {
    const cache = _chapterInfoCache[chapter['url']];

    return resolveFuture(fetch({
        'method': 'get',
        'url': ensureURL(mangaServerApiURL(cache['id'])),
        'headers': defaultHeaders
    }), fun (err, resp) {
        if (err != null) return throwError(err);

        const chapterURL: str = chapter['url'].replaceFirst(_serverURLPlaceholder, jsonDecode(resp['body'])['baseUrl']);

        return mapList(
            cache['files'],
            fun (i: num, x: Map) {
                return {
                    'url': ensureURL(pageSourceURL(chapterURL, x)),
                    'locale': chapter['locale']
                };
            }
        );
    });
}

fun getPage(page: Map) {
    return {
        'url': page['url'],
        'headers': defaultHeaders
    };
}